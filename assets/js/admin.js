// Admin Interface JavaScript
// ==========================

document.addEventListener('DOMContentLoaded', function() {
  
  // Post Editor Functionality
  const postForm = document.getElementById('post-form');
  const titleInput = document.getElementById('post-title');
  const slugInput = document.getElementById('post-slug');
  const contentTextarea = document.getElementById('post-content');
  const previewDiv = document.getElementById('content-preview');
  
  if (postForm) {
    // Auto-generate slug from title
    if (titleInput && slugInput) {
      titleInput.addEventListener('input', function() {
        if (!slugInput.value || slugInput.dataset.autoGenerated === 'true') {
          const slug = generateSlug(this.value);
          slugInput.value = slug;
          slugInput.dataset.autoGenerated = 'true';
        }
      });
      
      slugInput.addEventListener('input', function() {
        this.dataset.autoGenerated = 'false';
      });
    }
    
    // Toolbar functionality
    const toolbarButtons = document.querySelectorAll('.toolbar-btn');
    toolbarButtons.forEach(button => {
      button.addEventListener('click', function() {
        const action = this.dataset.action;
        handleToolbarAction(action);
      });
    });
    
    // Preview functionality
    const previewButton = document.querySelector('[data-action="preview"]');
    if (previewButton && contentTextarea && previewDiv) {
      previewButton.addEventListener('click', function() {
        togglePreview();
      });
    }
    
    // Form submission
    postForm.addEventListener('submit', function(e) {
      e.preventDefault();
      handlePostSubmission('publish');
    });
    
    // Draft saving
    const saveDraftButton = document.getElementById('save-draft');
    if (saveDraftButton) {
      saveDraftButton.addEventListener('click', function() {
        handlePostSubmission('draft');
      });
    }
    
    // Preview modal
    const previewPostButton = document.getElementById('preview-post');
    if (previewPostButton) {
      previewPostButton.addEventListener('click', function() {
        showPreviewModal();
      });
    }
  }
  
  // Tag Input Functionality
  const tagInputs = document.querySelectorAll('.tag-input');
  tagInputs.forEach(input => {
    setupTagInput(input);
  });
  
  // Image Preview
  const featuredImageInput = document.getElementById('featured-image');
  const imagePreview = document.getElementById('image-preview');
  
  if (featuredImageInput && imagePreview) {
    featuredImageInput.addEventListener('input', function() {
      const url = this.value;
      if (url) {
        imagePreview.innerHTML = `<img src="${url}" alt="Featured image preview" style="max-width: 200px; border-radius: 4px;">`;
      } else {
        imagePreview.innerHTML = '';
      }
    });
  }
  
  // Posts Management
  const postsSearch = document.getElementById('posts-search');
  const statusFilter = document.getElementById('status-filter');
  const categoryFilter = document.getElementById('category-filter');
  const sortFilter = document.getElementById('sort-filter');
  
  if (postsSearch) {
    postsSearch.addEventListener('input', function() {
      filterPosts();
    });
  }
  
  if (statusFilter) {
    statusFilter.addEventListener('change', filterPosts);
  }
  
  if (categoryFilter) {
    categoryFilter.addEventListener('change', filterPosts);
  }
  
  if (sortFilter) {
    sortFilter.addEventListener('change', sortPosts);
  }
  
  // Bulk Actions
  const selectAllPosts = document.getElementById('select-all-posts');
  const postCheckboxes = document.querySelectorAll('.post-checkbox');
  const bulkActionSelect = document.getElementById('bulk-action');
  const applyBulkButton = document.getElementById('apply-bulk');
  
  if (selectAllPosts) {
    selectAllPosts.addEventListener('change', function() {
      postCheckboxes.forEach(checkbox => {
        checkbox.checked = this.checked;
      });
    });
  }
  
  if (applyBulkButton) {
    applyBulkButton.addEventListener('click', function() {
      const action = bulkActionSelect.value;
      const selectedPosts = Array.from(postCheckboxes)
        .filter(cb => cb.checked)
        .map(cb => cb.value);
      
      if (action && selectedPosts.length > 0) {
        handleBulkAction(action, selectedPosts);
      }
    });
  }
  
  // Modal Management
  setupModals();
  
  // Category Management
  const addCategoryForm = document.getElementById('add-category-form');
  if (addCategoryForm) {
    addCategoryForm.addEventListener('submit', function(e) {
      e.preventDefault();
      handleAddCategory();
    });
  }
  
  // Tag Management
  const tagSearch = document.getElementById('tag-search');
  const tagSort = document.getElementById('tag-sort');
  
  if (tagSearch) {
    tagSearch.addEventListener('input', filterTags);
  }
  
  if (tagSort) {
    tagSort.addEventListener('change', sortTags);
  }
});

// Utility Functions
function generateSlug(text) {
  return text
    .toLowerCase()
    .replace(/[^a-z0-9 -]/g, '')
    .replace(/\s+/g, '-')
    .replace(/-+/g, '-')
    .trim('-');
}

function handleToolbarAction(action) {
  const textarea = document.getElementById('post-content');
  if (!textarea) return;
  
  const start = textarea.selectionStart;
  const end = textarea.selectionEnd;
  const selectedText = textarea.value.substring(start, end);
  let replacement = '';
  
  switch (action) {
    case 'bold':
      replacement = `**${selectedText || 'bold text'}**`;
      break;
    case 'italic':
      replacement = `*${selectedText || 'italic text'}*`;
      break;
    case 'heading':
      replacement = `## ${selectedText || 'Heading'}`;
      break;
    case 'link':
      const url = prompt('Enter URL:');
      replacement = `[${selectedText || 'link text'}](${url || '#'})`;
      break;
    case 'image':
      const imgUrl = prompt('Enter image URL:');
      const altText = prompt('Enter alt text:') || 'image';
      replacement = `![${altText}](${imgUrl || '#'})`;
      break;
    case 'code':
      if (selectedText.includes('\n')) {
        replacement = `\`\`\`\n${selectedText || 'code block'}\n\`\`\``;
      } else {
        replacement = `\`${selectedText || 'code'}\``;
      }
      break;
    case 'list':
      replacement = `- ${selectedText || 'list item'}`;
      break;
    case 'quote':
      replacement = `> ${selectedText || 'quote'}`;
      break;
  }
  
  if (replacement) {
    textarea.setRangeText(replacement, start, end, 'end');
    textarea.focus();
  }
}

function togglePreview() {
  const textarea = document.getElementById('post-content');
  const preview = document.getElementById('content-preview');
  const button = document.querySelector('[data-action="preview"]');
  
  if (preview.style.display === 'none' || !preview.style.display) {
    // Show preview
    preview.innerHTML = markdownToHtml(textarea.value);
    preview.style.display = 'block';
    textarea.style.display = 'none';
    button.classList.add('active');
  } else {
    // Show editor
    preview.style.display = 'none';
    textarea.style.display = 'block';
    button.classList.remove('active');
  }
}

function markdownToHtml(markdown) {
  // Simple markdown to HTML conversion
  // In a real implementation, you'd use a proper markdown parser
  return markdown
    .replace(/^### (.*$)/gim, '<h3>$1</h3>')
    .replace(/^## (.*$)/gim, '<h2>$1</h2>')
    .replace(/^# (.*$)/gim, '<h1>$1</h1>')
    .replace(/\*\*(.*)\*\*/gim, '<strong>$1</strong>')
    .replace(/\*(.*)\*/gim, '<em>$1</em>')
    .replace(/\`(.*)\`/gim, '<code>$1</code>')
    .replace(/\n/gim, '<br>');
}

function setupTagInput(input) {
  const container = input.closest('.tag-input-container');
  const suggestions = container.querySelector('.tag-suggestions');
  const selectedContainer = container.parentElement.querySelector('.selected-tags');
  
  let selectedTags = [];
  
  input.addEventListener('input', function() {
    const value = this.value.toLowerCase();
    if (value.length > 0) {
      showSuggestions(suggestions, value);
    } else {
      hideSuggestions(suggestions);
    }
  });
  
  input.addEventListener('keydown', function(e) {
    if (e.key === 'Enter' || e.key === ',') {
      e.preventDefault();
      addTag(this.value.trim());
      this.value = '';
      hideSuggestions(suggestions);
    }
  });
  
  input.addEventListener('blur', function() {
    setTimeout(() => hideSuggestions(suggestions), 200);
  });
  
  // Handle suggestion clicks
  suggestions.addEventListener('click', function(e) {
    if (e.target.classList.contains('tag-suggestion')) {
      addTag(e.target.dataset.value);
      input.value = '';
      hideSuggestions(suggestions);
    }
  });
  
  function addTag(tag) {
    if (tag && !selectedTags.includes(tag)) {
      selectedTags.push(tag);
      updateSelectedTags();
    }
  }
  
  function removeTag(tag) {
    selectedTags = selectedTags.filter(t => t !== tag);
    updateSelectedTags();
  }
  
  function updateSelectedTags() {
    selectedContainer.innerHTML = selectedTags.map(tag => 
      `<span class="selected-tag">
        ${tag}
        <span class="remove-tag" onclick="removeTag('${tag}')">&times;</span>
      </span>`
    ).join('');
    
    // Update hidden input value
    input.value = selectedTags.join(', ');
  }
  
  function showSuggestions(suggestions, filter) {
    const items = suggestions.querySelectorAll('.tag-suggestion');
    let hasVisible = false;
    
    items.forEach(item => {
      const text = item.textContent.toLowerCase();
      if (text.includes(filter) && !selectedTags.includes(item.dataset.value)) {
        item.style.display = 'block';
        hasVisible = true;
      } else {
        item.style.display = 'none';
      }
    });
    
    suggestions.style.display = hasVisible ? 'block' : 'none';
  }
  
  function hideSuggestions(suggestions) {
    suggestions.style.display = 'none';
  }
  
  // Make removeTag function global for this input
  window.removeTag = removeTag;
}

function handlePostSubmission(type) {
  const formData = new FormData(document.getElementById('post-form'));
  const postData = Object.fromEntries(formData.entries());
  
  // Set published status based on type
  postData.published = type === 'publish';
  
  // Generate Jekyll front matter
  const frontMatter = generateFrontMatter(postData);
  const fullContent = frontMatter + '\n\n' + postData.content;
  
  // In a real implementation, this would save to the file system
  // For now, we'll just show the generated content
  console.log('Generated post content:', fullContent);
  
  // Show success message
  showNotification(`Post ${type === 'publish' ? 'published' : 'saved as draft'} successfully!`, 'success');
}

function generateFrontMatter(data) {
  const date = data.date || new Date().toISOString();
  const categories = data.categories ? data.categories.split(',').map(c => c.trim()) : [];
  const tags = data.tags ? data.tags.split(',').map(t => t.trim()) : [];
  
  return `---
layout: post
title: "${data.title}"
date: ${date}
categories: [${categories.map(c => `"${c}"`).join(', ')}]
tags: [${tags.map(t => `"${t}"`).join(', ')}]
excerpt: "${data.excerpt || ''}"
featured_image: "${data.featured_image || ''}"
author: "${data.author || ''}"
published: ${data.published}
---`;
}

function filterPosts() {
  const searchTerm = document.getElementById('posts-search').value.toLowerCase();
  const statusFilter = document.getElementById('status-filter').value;
  const categoryFilter = document.getElementById('category-filter').value.toLowerCase();
  
  const rows = document.querySelectorAll('.post-row');
  let visibleCount = 0;
  
  rows.forEach(row => {
    const title = row.dataset.title;
    const status = row.dataset.status;
    const categories = row.dataset.categories;
    
    const matchesSearch = !searchTerm || title.includes(searchTerm);
    const matchesStatus = !statusFilter || status === statusFilter;
    const matchesCategory = !categoryFilter || categories.includes(categoryFilter);
    
    if (matchesSearch && matchesStatus && matchesCategory) {
      row.style.display = '';
      visibleCount++;
    } else {
      row.style.display = 'none';
    }
  });
  
  // Update posts count
  const postsCount = document.getElementById('posts-count');
  if (postsCount) {
    postsCount.textContent = visibleCount;
  }
}

function sortPosts() {
  const sortBy = document.getElementById('sort-filter').value;
  const tbody = document.getElementById('posts-table-body');
  const rows = Array.from(tbody.querySelectorAll('.post-row'));
  
  rows.sort((a, b) => {
    switch (sortBy) {
      case 'date-desc':
        return new Date(b.dataset.date) - new Date(a.dataset.date);
      case 'date-asc':
        return new Date(a.dataset.date) - new Date(b.dataset.date);
      case 'title-asc':
        return a.dataset.title.localeCompare(b.dataset.title);
      case 'title-desc':
        return b.dataset.title.localeCompare(a.dataset.title);
      default:
        return 0;
    }
  });
  
  rows.forEach(row => tbody.appendChild(row));
}

function handleBulkAction(action, postIds) {
  const confirmMessage = `Are you sure you want to ${action} ${postIds.length} posts?`;
  
  if (confirm(confirmMessage)) {
    // In a real implementation, this would perform the bulk action
    console.log(`Performing ${action} on posts:`, postIds);
    showNotification(`Bulk ${action} completed successfully!`, 'success');
  }
}

function setupModals() {
  // Generic modal setup
  const modals = document.querySelectorAll('.modal');
  
  modals.forEach(modal => {
    const closeBtn = modal.querySelector('.modal-close');
    
    if (closeBtn) {
      closeBtn.addEventListener('click', () => {
        modal.classList.remove('show');
      });
    }
    
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        modal.classList.remove('show');
      }
    });
  });
}

function showPreviewModal() {
  const modal = document.getElementById('preview-modal');
  const content = document.getElementById('post-content').value;
  const previewContent = document.getElementById('preview-content');
  
  if (modal && previewContent) {
    previewContent.innerHTML = markdownToHtml(content);
    modal.classList.add('show');
  }
}

function handleAddCategory() {
  const form = document.getElementById('add-category-form');
  const formData = new FormData(form);
  const categoryData = Object.fromEntries(formData.entries());
  
  // In a real implementation, this would save the category
  console.log('Adding category:', categoryData);
  showNotification('Category added successfully!', 'success');
  form.reset();
}

function filterTags() {
  const searchTerm = document.getElementById('tag-search').value.toLowerCase();
  const rows = document.querySelectorAll('.tag-row');
  
  rows.forEach(row => {
    const tagName = row.dataset.tag;
    if (tagName.includes(searchTerm)) {
      row.style.display = '';
    } else {
      row.style.display = 'none';
    }
  });
}

function sortTags() {
  const sortBy = document.getElementById('tag-sort').value;
  const tbody = document.getElementById('tags-table-body');
  const rows = Array.from(tbody.querySelectorAll('.tag-row'));
  
  rows.sort((a, b) => {
    switch (sortBy) {
      case 'name-asc':
        return a.dataset.tag.localeCompare(b.dataset.tag);
      case 'name-desc':
        return b.dataset.tag.localeCompare(a.dataset.tag);
      case 'count-desc':
        return parseInt(b.dataset.count) - parseInt(a.dataset.count);
      case 'count-asc':
        return parseInt(a.dataset.count) - parseInt(b.dataset.count);
      default:
        return 0;
    }
  });
  
  rows.forEach(row => tbody.appendChild(row));
}

function showNotification(message, type = 'info') {
  // Create notification element
  const notification = document.createElement('div');
  notification.className = `notification notification-${type}`;
  notification.textContent = message;
  
  // Style the notification
  Object.assign(notification.style, {
    position: 'fixed',
    top: '20px',
    right: '20px',
    padding: '1rem 1.5rem',
    borderRadius: '6px',
    color: 'white',
    fontWeight: '500',
    zIndex: '9999',
    transform: 'translateX(100%)',
    transition: 'transform 0.3s ease'
  });
  
  // Set background color based on type
  const colors = {
    success: '#10b981',
    error: '#ef4444',
    warning: '#f59e0b',
    info: '#3b82f6'
  };
  notification.style.backgroundColor = colors[type] || colors.info;
  
  // Add to page
  document.body.appendChild(notification);
  
  // Animate in
  setTimeout(() => {
    notification.style.transform = 'translateX(0)';
  }, 100);
  
  // Remove after delay
  setTimeout(() => {
    notification.style.transform = 'translateX(100%)';
    setTimeout(() => {
      document.body.removeChild(notification);
    }, 300);
  }, 3000);
}